# ============================================================================
# ALGOSHARE GATEWAY - Production Configuration
# ============================================================================
# Architecture: Central entry point for all external traffic
# Security: JWT validation via OAuth2 Resource Server
# Resilience: Circuit Breakers + Rate Limiting + Fallbacks
# Author: Aditya
# Last Updated: January 8, 2026
# ============================================================================

server:
  port: 8081
  shutdown: graceful
  netty:
    connection-timeout: 10s
    idle-timeout: 60s

# ============================================================================
# Spring Application Configuration
# ============================================================================
spring:
  application:
    name: algoshare-gateway

  # --------------------------------------------------------------------------
  # Redis Configuration (Distributed Rate Limiting)
  # --------------------------------------------------------------------------
  # Interview QA: "Why Redis for Rate Limiting?"
  # A: "For distributed systems with multiple Gateway instances, Redis provides
  #     shared state. All replicas see the same token bucket counters via Lua
  #     scripts, ensuring consistent rate limits regardless of which Gateway
  #     instance handles the request. The atomic Lua execution prevents race
  #     conditions across distributed instances."
  # --------------------------------------------------------------------------
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      database: 0
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
          max-wait: 2000ms
        shutdown-timeout: 100ms

  # --------------------------------------------------------------------------
  # OAuth2 Resource Server (JWT Validation)
  # --------------------------------------------------------------------------
  # Interview QA: "How does the Gateway validate JWTs without calling Auth Service?"
  # A: "The Gateway fetches the issuer's OIDC metadata from 
  #     /.well-known/openid-configuration, retrieves the JWK Set (public keys),
  #     and verifies JWT signatures locally using RS256 algorithm. This is
  #     stateless verification - no database or network call needed per request.
  #     The public keys are cached and periodically refreshed."
  # --------------------------------------------------------------------------
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${AUTH_ISSUER_URI:http://localhost:8085}
          # Automatically discovers:
          # - JWK Set URI: {issuer-uri}/.well-known/jwks.json
          # - Claims validation (iss, exp, nbf)

  # --------------------------------------------------------------------------
  # Spring Cloud Gateway Routes
  # --------------------------------------------------------------------------
  # Interview QA: "Explain the Gateway's routing strategy"
  # A: "Each route uses predicates to match incoming requests (Path, Method,
  #     Headers) and applies filters for cross-cutting concerns (Authentication,
  #     Rate Limiting, Circuit Breaking). The 'lb://' URI scheme enables client-side
  #     load balancing across service instances registered with service discovery.
  #     Filters execute in order: Global â†’ Route-specific â†’ Default."
  # --------------------------------------------------------------------------
  cloud:
    gateway:
      # ----------------------------------------------------------------------
      # Global CORS Configuration
      # ----------------------------------------------------------------------
      globalcors:
        add-to-simple-url-handler-mapping: true
        cors-configurations:
          '[/**]':
            allowedOrigins:
              - "http://localhost:3000"        # React dev server
              - "http://localhost:3001"        # React prod build
              - "https://algoshare.io"         # Production domain
              - "https://www.algoshare.io"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - PATCH
              - OPTIONS
            allowedHeaders:
              - "*"
            exposedHeaders:
              - X-RateLimit-Limit
              - X-RateLimit-Remaining
              - X-RateLimit-Reset
              - Retry-After
            allowCredentials: true
            maxAge: 3600

      # ----------------------------------------------------------------------
      # Default Filters (Applied to ALL routes)
      # ----------------------------------------------------------------------
      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Origin Access-Control-Allow-Credentials, RETAIN_UNIQUE
        # Retry moved to route-specific filters for proper ordering with Circuit Breaker

      # ----------------------------------------------------------------------
      # FILTER EXECUTION ORDER (Request â†’ Response Flow)
      # ----------------------------------------------------------------------
      # Understanding how filters execute is CRITICAL for debugging and interviews!
      #
      # FORWARD PATH (Client â†’ Downstream Service):
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # 1ï¸âƒ£ Client sends request â†’ Gateway
      #
      # 2ï¸âƒ£ Spring Security (Global Filter - HIGHEST_PRECEDENCE)
      #     - Validate JWT signature using JWK Set from Auth Service
      #     - Extract principal (user identity)
      #     - Set ReactiveSecurityContext
      #     - Reject if invalid âŒ (return 401 Unauthorized)
      #
      # 3ï¸âƒ£ UserContextFilter (Global Filter - LOWEST_PRECEDENCE - 10)
      #     - Read JWT from ReactiveSecurityContext
      #     - Extract claims: userId (sub), issuer (iss)
      #     - Add headers for downstream services:
      #         â†’ X-User-Id: {userId}
      #         â†’ X-Token-Issuer: {issuer}
      #
      # 4ï¸âƒ£ DedupeResponseHeader (Default Filter)
      #     - No action on request (processes response only)
      #
      # 5ï¸âƒ£ AlgoShareRateLimit (Route-Specific Filter #1)
      #     - Check Redis token bucket: capacity, refillRate
      #     - Example: User has 150/200 tokens âœ…
      #     - Consume 1 token â†’ 149/200 remaining
      #     - If quota exceeded â†’ Reject with 429 Too Many Requests âŒ
      #
      # 6ï¸âƒ£ AlgoShareBulkhead (Route-Specific Filter #2)
      #     - Check concurrent request slots
      #     - Example: 45/100 slots used âœ…
      #     - Acquire slot â†’ 46/100
      #     - If full â†’ Queue (if enabled) or Reject with 429 âŒ
      #
      # 7ï¸âƒ£ AlgoShareTimeout (Route-Specific Filter #3)
      #     - Start Reactor timeout timer (e.g., 3 seconds for order service)
      #     - Schedule timeout task on event loop
      #     - If timeout fires â†’ Cancel downstream, return 504 Gateway Timeout âŒ
      #
      # 8ï¸âƒ£ AlgoShareRetry (Route-Specific Filter #4)
      #     - Wrap downstream call with retry logic
      #     - Setup retry context (no retry yet on first attempt)
      #     - On failure â†’ Check if retriable â†’ Sleep (backoff) â†’ Retry
      #     - On CircuitOpenException â†’ STOP retrying âŒ
      #
      # 9ï¸âƒ£ AlgoShareCircuitBreaker (Route-Specific Filter #5) [FINAL GUARDIAN]
      #     - Check circuit state:
      #         CLOSED âœ… â†’ Allow request, track start time
      #         OPEN âŒ â†’ Reject immediately (503), no downstream call
      #         HALF_OPEN âš ï¸ â†’ Allow limited probe requests
      #     - Record request in sliding window
      #     - Why LAST? â†’ Observes final outcome after ALL retries
      #
      # ğŸ”Ÿ ReactiveLoadBalancerClientFilter (Global Built-in - Order: -10150)
      #     - Resolve service name (e.g., algoshare-order)
      #     - Query Eureka/Consul for available instances
      #     - Select instance using load balancing (Round Robin, Random, etc.)
      #     - Example: 192.168.1.10:8083
      #
      # 1ï¸âƒ£1ï¸âƒ£ NettyRoutingFilter (Global Built-in - LOWEST_PRECEDENCE)
      #     - Make actual HTTP call using Netty WebClient
      #     - Service responds: 200 OK in 150ms (example)
      #
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # RETURN PATH (Downstream Service â†’ Client):
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Filters execute in REVERSE order on the response!
      #
      # 1ï¸âƒ£1ï¸âƒ£ NettyRoutingFilter: Receives HTTP response from service
      # ğŸ”Ÿ LoadBalancerClientFilter: No action on response
      # 9ï¸âƒ£ CircuitBreaker: Record SUCCESS/FAILURE, update metrics
      # 8ï¸âƒ£ Retry: Success on first attempt (no retry needed)
      # 7ï¸âƒ£ Timeout: Cancel timeout task (request completed in 150ms)
      # 6ï¸âƒ£ Bulkhead: Release slot â†’ 45/100 (back to original)
      # 5ï¸âƒ£ RateLimit: No action on response
      # 4ï¸âƒ£ DedupeResponseHeader: Remove duplicate CORS headers
      # 3ï¸âƒ£ UserContextFilter: No action on response
      # 2ï¸âƒ£ Spring Security: No action on response
      # 1ï¸âƒ£ Client receives response: 200 OK
      #
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # KEY PRINCIPLES (Interview Gold!):
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # âœ… Global filters run on EVERY request (Security, UserContext, etc.)
      # âœ… Default filters run on ALL routes (DedupeResponseHeader)
      # âœ… Route filters run only for matched routes (Rate Limit, etc.)
      # âœ… Filters execute in ORDER on request, REVERSE on response
      # âœ… RateLimit FIRST â†’ Fail fast, save resources
      # âœ… CircuitBreaker LAST â†’ Observe final outcomes after retries
      # âœ… Retry wraps CB â†’ Each retry checks circuit state
      # âœ… Timeout before Retry â†’ Retry can handle timeout exceptions
      # âœ… Circuit states: CLOSED = Allow âœ…, OPEN = Reject âŒ
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      # ----------------------------------------------------------------------
      # Route Definitions
      # ----------------------------------------------------------------------
      routes:
        # ====================================================================
        # Route 1: Auth Service (Public - No Rate Limiting)
        # ====================================================================
        # Endpoints: /auth/register, /auth/login, /auth/refresh
        # Security: Public (JWT not required)
        # Requirements: FR-5 (Identity Provider)
        # ====================================================================
        - id: auth-service
          uri: lb://algoshare-auth
          predicates:
            - Path=/auth/**
          filters:
            - StripPrefix=0
            - name: CircuitBreaker
              args:
                name: auth-cb
                fallbackUri: forward:/fallback/auth
          metadata:
            response-timeout: 5000
            connect-timeout: 3000

        # ====================================================================
        # Route 2: User Payment Service (CRITICAL - Money Operations)
        # ====================================================================
        # Endpoints: /api/user-payment/wallet, /api/user-payment/deposit
        # Security: JWT Required
        # Requirements: FR-4 (Wallet Management, Stripe Integration, Fund Locking)
        # Rate Limit: 100 requests/minute (moderate)
        # Circuit Breaker: Strict (money operations, fail closed)
        # ====================================================================
        - id: user-payment-service
          uri: lb://algoshare-user-payment
          predicates:
            - Path=/api/user-payment/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            # Ensures: Circuit Breaker observes final outcomes after retries
            
            # 1ï¸âƒ£ Rate Limiting (Block abuse early)
            - name: AlgoShareRateLimit
              args:
                name: payment-limiter
                capacity: 100
                refillRate: 1.66              # 100 per minute
                tokensPerRequest: 1
                ttl: 120
                failOpen: false               # CRITICAL: Don't allow on Redis failure

            # 2ï¸âƒ£ Bulkhead (Limit concurrency)
            - name: AlgoShareBulkhead
              args:
                name: payment-bulkhead
                maxConcurrent: 50
                queueCapacity: 10
                queueTimeoutMs: 2000

            # 3ï¸âƒ£ Timeout (Fail fast on slowness)
            - name: AlgoShareTimeout
              args:
                serviceName: payment-service
                timeoutMs: 5000

            # 4ï¸âƒ£ Retry (Recover from transient failures)
            - name: AlgoShareRetry
              args:
                name: payment-retry
                retries: 3
                statuses: SERVICE_UNAVAILABLE,GATEWAY_TIMEOUT
                methods: GET,POST
                backoff:
                  firstBackoff: 100ms
                  maxBackoff: 1000ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker (Final guardian - observes final outcomes)
            - name: AlgoShareCircuitBreaker
              args:
                name: payment-cb
                failureThreshold: 5
                resetTimeout: 10000           # 10 seconds
                slowCallThreshold: 300        # 300ms
                successThreshold: 3
                slidingWindowSize: 20
                halfOpenPermits: 3
                fallbackUri: forward:/fallback/payment

        # ====================================================================
        # Route 3: Order Execution Service (CRITICAL - Trading Operations)
        # ====================================================================
        # Endpoints: /api/order/execute, /api/order/portfolio, /api/order/history
        # Security: JWT Required
        # Requirements: FR-3 (Signal Processing, Two-Phase Fund Locking, Portfolio)
        #               NFR-2 (<50ms tick-to-signal latency)
        # Rate Limit: 200 requests/minute (high - automated trading)
        # Circuit Breaker: Very strict (3 failures, 5s timeout)
        # ====================================================================
        - id: order-service
          uri: lb://algoshare-order
          predicates:
            - Path=/api/order/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            
            # 1ï¸âƒ£ Rate Limiting
            - name: AlgoShareRateLimit
              args:
                name: order-limiter
                capacity: 200
                refillRate: 3.33              # 200 per minute
                tokensPerRequest: 1
                ttl: 120
                failOpen: false               # CRITICAL: Trading operations

            # 2ï¸âƒ£ Bulkhead
            - name: AlgoShareBulkhead
              args:
                name: order-bulkhead
                maxConcurrent: 100
                queueCapacity: 20
                queueTimeoutMs: 1000

            # 3ï¸âƒ£ Timeout (Strict - NFR-2 requirement)
            - name: AlgoShareTimeout
              args:
                serviceName: order-service
                timeoutMs: 3000

            # 4ï¸âƒ£ Retry (Limited for trading operations)
            - name: AlgoShareRetry
              args:
                name: order-retry
                retries: 2                    # Fewer retries for trading
                statuses: SERVICE_UNAVAILABLE
                methods: GET                  # Only retry safe operations
                backoff:
                  firstBackoff: 50ms
                  maxBackoff: 500ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker (Very strict)
            - name: AlgoShareCircuitBreaker
              args:
                name: order-cb
                failureThreshold: 3           # Low tolerance
                resetTimeout: 5000            # 5 seconds (quick recovery)
                slowCallThreshold: 200        # 200ms max (NFR-2 requirement)
                successThreshold: 3
                slidingWindowSize: 20
                halfOpenPermits: 2
                fallbackUri: forward:/fallback/order

        # ====================================================================
        # Route 4: AI Financial Assistant (EXPENSIVE - LLM API)
        # ====================================================================
        # Endpoints: /api/ai/chat, /api/ai/summary, /api/ai/train
        # Security: JWT Required
        # Requirements: FR-6.4 (10 requests/minute rate limit)
        #               FR-7 (Context-aware chat, Market summaries)
        # Rate Limit: STRICT (prevent abuse of expensive LLM API)
        # Circuit Breaker: Relaxed (external API can be slow, 5-10s acceptable)
        # ====================================================================
        - id: ai-service-chat
          uri: lb://algoshare-ai
          predicates:
            - Path=/api/ai/chat/**,/api/ai/summary/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            
            # 1ï¸âƒ£ Rate Limiting (FR-6.4: AI Chat limited to 10/minute)
            - name: AlgoShareRateLimit
              args:
                name: ai-chat-limiter
                capacity: 10
                refillRate: 0.166             # 10 per minute = 0.166/sec
                tokensPerRequest: 1
                ttl: 120
                failOpen: true                # Allow on Redis failure (not critical)

            # 2ï¸âƒ£ Bulkhead (Limit concurrent LLM calls)
            - name: AlgoShareBulkhead
              args:
                name: ai-chat-bulkhead
                maxConcurrent: 10
                queueCapacity: 5
                queueTimeoutMs: 5000

            # 3ï¸âƒ£ Timeout (LLM can be slow)
            - name: AlgoShareTimeout
              args:
                serviceName: ai-chat-service
                timeoutMs: 10000              # 10 seconds for LLM

            # 4ï¸âƒ£ Retry (Don't retry LLM calls - expensive)
            - name: AlgoShareRetry
              args:
                name: ai-chat-retry
                retries: 1                    # Minimal retry for expensive LLM calls
                statuses: SERVICE_UNAVAILABLE
                methods: GET
                backoff:
                  firstBackoff: 1000ms
                  maxBackoff: 2000ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker (Relaxed - external API)
            - name: AlgoShareCircuitBreaker
              args:
                name: ai-chat-cb
                failureThreshold: 5           # Relaxed (external LLM can be slow)
                resetTimeout: 30000           # 30 seconds
                slowCallThreshold: 5000       # 5 seconds (LLM responses take time)
                successThreshold: 2
                slidingWindowSize: 20
                halfOpenPermits: 3
                fallbackUri: forward:/fallback/ai

        # AI Training Endpoint (Very Expensive - Different Rate Limit)
        - id: ai-service-training
          uri: lb://algoshare-ai
          predicates:
            - Path=/api/ai/train/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            
            # 1ï¸âƒ£ Rate Limiting (VERY strict - expensive LLM training)
            - name: AlgoShareRateLimit
              args:
                name: ai-training-limiter
                capacity: 5
                refillRate: 0.083             # 5 per minute
                tokensPerRequest: 5           # Each training request costs 5 tokens!
                ttl: 300                      # 5 minutes TTL
                failOpen: false               # Don't allow on errors (very expensive)

            # 2ï¸âƒ£ Bulkhead (Severely limit concurrent training)
            - name: AlgoShareBulkhead
              args:
                name: ai-training-bulkhead
                maxConcurrent: 3
                queueCapacity: 2
                queueTimeoutMs: 10000

            # 3ï¸âƒ£ Timeout (Long timeout for training)
            - name: AlgoShareTimeout
              args:
                serviceName: ai-training-service
                timeoutMs: 30000              # 30 seconds for training

            # 4ï¸âƒ£ Retry (NO retry for expensive training)
            - name: AlgoShareRetry
              args:
                name: ai-training-retry
                retries: 0                    # No retry - too expensive!
                statuses: SERVICE_UNAVAILABLE
                methods: POST
                backoff:
                  firstBackoff: 1000ms
                  maxBackoff: 2000ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker
            - name: AlgoShareCircuitBreaker
              args:
                name: ai-training-cb
                failureThreshold: 3
                resetTimeout: 60000           # 1 minute
                slowCallThreshold: 10000      # 10 seconds
                successThreshold: 2
                halfOpenPermits: 2
                fallbackUri: forward:/fallback/ai

        # ====================================================================
        # Route 5: Strategy Service (HIGH FREQUENCY - Tick Processing)
        # ====================================================================
        # Endpoints: /api/strategy/create, /api/strategy/activate, /api/strategy/list
        # Security: JWT Required
        # Requirements: FR-2 (Rule Creation, Redis Hot Cache, Kafka Consumption)
        #               NFR-2 (<50ms tick processing)
        # Rate Limit: 1000 requests/minute (very high - continuous tick processing)
        # Circuit Breaker: Moderate (high tolerance for high frequency)
        # ====================================================================
        - id: strategy-service
          uri: lb://algoshare-strategy
          predicates:
            - Path=/api/strategy/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            
            # 1ï¸âƒ£ Rate Limiting (Very high - continuous tick processing)
            - name: AlgoShareRateLimit
              args:
                name: strategy-limiter
                capacity: 1000
                refillRate: 16.66             # 1000 per minute
                tokensPerRequest: 1
                ttl: 120
                failOpen: true                # Don't block on Redis failure

            # 2ï¸âƒ£ Bulkhead (High concurrency for high frequency)
            - name: AlgoShareBulkhead
              args:
                name: strategy-bulkhead
                maxConcurrent: 200
                queueCapacity: 50
                queueTimeoutMs: 500

            # 3ï¸âƒ£ Timeout (Must be fast for NFR-2)
            - name: AlgoShareTimeout
              args:
                serviceName: strategy-service
                timeoutMs: 2000

            # 4ï¸âƒ£ Retry (Quick retries for high frequency)
            - name: AlgoShareRetry
              args:
                name: strategy-retry
                retries: 2
                statuses: SERVICE_UNAVAILABLE
                methods: GET,POST
                backoff:
                  firstBackoff: 20ms
                  maxBackoff: 100ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker (Moderate - high tolerance)
            - name: AlgoShareCircuitBreaker
              args:
                name: strategy-cb
                failureThreshold: 10          # High tolerance (high frequency)
                resetTimeout: 10000           # 10 seconds
                slowCallThreshold: 100        # 100ms (must be fast for NFR-2)
                successThreshold: 3
                slidingWindowSize: 50
                halfOpenPermits: 5
                fallbackUri: forward:/fallback/strategy

        # ====================================================================
        # Route 6A: Market Data Ingestion (INTERNAL - Not Exposed)
        # ====================================================================
        # Purpose: WebSocket ingestion FROM Binance, Kafka production
        # Requirements: FR-1 (Real-time feed, >1000 events/sec)
        # Note: Internal service only (not accessible from frontend)
        # ====================================================================
        - id: ingestion-service-internal
          uri: lb://algoshare-ingestion
          predicates:
            - Path=/internal/ingestion/**
          filters:
            - name: AlgoShareCircuitBreaker
              args:
                name: ingestion-cb
                failureThreshold: 20          # Very high tolerance
                resetTimeout: 5000
                slowCallThreshold: 50         # Must be very fast
                successThreshold: 5
                halfOpenPermits: 10
          metadata:
            response-timeout: 1000

        # ====================================================================
        # Route 6B: Market Data Query (PUBLIC - Frontend Consumption)
        # ====================================================================
        # Endpoints: /api/market/price/{symbol}, /api/market/prices
        # Security: Public (no JWT required for read-only market data)
        # Purpose: Serve latest prices to frontend dashboards
        # Rate Limit: 1000 requests/minute (high - dashboard polling)
        # ====================================================================
        - id: market-data-rest
          uri: lb://algoshare-market-data
          predicates:
            - Path=/api/market/price/**,/api/market/prices/**
          filters:
            # Filter Order: RateLimit â†’ Bulkhead â†’ Timeout â†’ Retry â†’ CircuitBreaker
            # IP-based rate limiting (public endpoint)
            
            # 1ï¸âƒ£ Rate Limiting
            - name: AlgoShareRateLimit
              args:
                name: market-data-limiter
                capacity: 1000                # High throughput for dashboards
                refillRate: 16.66             # 1000 per minute
                tokensPerRequest: 1
                ttl: 60
                failOpen: true                # Non-critical, fail open

            # 2ï¸âƒ£ Bulkhead
            - name: AlgoShareBulkhead
              args:
                name: market-data-bulkhead
                maxConcurrent: 200
                queueCapacity: 50
                queueTimeoutMs: 1000

            # 3ï¸âƒ£ Timeout
            - name: AlgoShareTimeout
              args:
                serviceName: market-data-service
                timeoutMs: 2000

            # 4ï¸âƒ£ Retry
            - name: AlgoShareRetry
              args:
                name: market-data-retry
                retries: 2
                statuses: SERVICE_UNAVAILABLE
                methods: GET
                backoff:
                  firstBackoff: 50ms
                  maxBackoff: 500ms
                  factor: 2

            # 5ï¸âƒ£ Circuit Breaker
            - name: AlgoShareCircuitBreaker
              args:
                name: market-data-cb
                failureThreshold: 10
                resetTimeout: 5000
                slowCallThreshold: 100
                successThreshold: 3
                halfOpenPermits: 5

        # ====================================================================
        # Route 6C: Market Data WebSocket (REAL-TIME STREAMING)
        # ====================================================================
        # Endpoint: /api/market/stream/{symbol}
        # Purpose: WebSocket connection for live price updates to frontend
        # Frontend: ws://gateway:8081/api/market/stream/BTCUSDT
        # Rate Limit: Connection-based (no per-request limit)
        # ====================================================================
        - id: market-data-websocket
          uri: lb:ws://algoshare-market-data
          predicates:
            - Path=/api/market/stream/**
          filters:
            # No rate limiting (connection-based throttling at service level)
            - name: AlgoShareCircuitBreaker
              args:
                name: market-ws-cb
                failureThreshold: 5
                resetTimeout: 10000
                slowCallThreshold: 200
                successThreshold: 2
                halfOpenPermits: 3
          metadata:
            response-timeout: 30000           # Long timeout for WebSocket

        # ====================================================================
        # Fallback Routes (Circuit Breaker Open)
        # ====================================================================
        - id: fallback-auth
          uri: forward:/fallback/auth
          predicates:
            - Path=/fallback/auth

        - id: fallback-payment
          uri: forward:/fallback/payment
          predicates:
            - Path=/fallback/payment

        - id: fallback-order
          uri: forward:/fallback/order
          predicates:
            - Path=/fallback/order

        - id: fallback-ai
          uri: forward:/fallback/ai
          predicates:
            - Path=/fallback/ai

        - id: fallback-strategy
          uri: forward:/fallback/strategy
          predicates:
            - Path=/fallback/strategy

      # ----------------------------------------------------------------------
      # Gateway Metrics Configuration
      # ----------------------------------------------------------------------
      metrics:
        enabled: true

      # ----------------------------------------------------------------------
      # HTTP Client Configuration
      # ----------------------------------------------------------------------
      httpclient:
        connect-timeout: 3000
        response-timeout: 5s
        pool:
          type: elastic
          max-connections: 500
          max-idle-time: 60s
        wiretap: true                        # Enable request/response logging

# ============================================================================
# Management & Observability (Actuator)
# ============================================================================
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,gateway,circuitbreakers,ratelimiters
      base-path: /actuator

  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
    gateway:
      enabled: true                          # /actuator/gateway/routes

  health:
    redis:
      enabled: true
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true

  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:development}
    distribution:
      percentiles-histogram:
        http.server.requests: true

  # Graceful Shutdown
  server:
    shutdown: graceful

# ============================================================================
# Logging Configuration
# ============================================================================
logging:
  level:
    root: INFO
    org.springframework.cloud.gateway: DEBUG
    org.springframework.security: DEBUG
    org.springframework.web.reactive: DEBUG
    com.algoshare.gateway: DEBUG
    reactor.netty: INFO
    io.lettuce.core: INFO

  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"

  file:
    name: logs/gateway.log
    max-size: 10MB
    max-history: 30
    total-size-cap: 1GB

# ============================================================================
# Environment-Specific Overrides
# ============================================================================
# These can be overridden via:
# - application-dev.yml
# - application-prod.yml
# - Environment variables
# - Command-line arguments: --spring.profiles.active=prod
# ============================================================================

---
# Development Profile
spring:
  config:
    activate:
      on-profile: dev

  data:
    redis:
      host: localhost

  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8085

logging:
  level:
    root: DEBUG
    org.springframework.cloud.gateway: TRACE

---
# Production Profile
spring:
  config:
    activate:
      on-profile: prod

  data:
    redis:
      host: redis-cluster.algoshare.internal
      password: ${REDIS_PASSWORD}
      ssl:
        enabled: true

  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://auth.algoshare.io

logging:
  level:
    root: WARN
    com.algoshare.gateway: INFO

  file:
    name: /var/log/algoshare/gateway.log
